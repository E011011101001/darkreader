import {styleManagers} from './index';
import {forEach} from '../../utils/array';
import {overridesList} from './inline-style';

function beautify(text: string) {

    const CSS = (text
        .replace(/\{/g,'{%--%') // {
        .replace(/\}/g,'%--%}%--%') // }
        .replace(/\;/g,';%--%') // ;
        .replace(/%--%\s{0,}%--%/g,'%--%') // Remove %--% Without any characters between to next %--%
        .split('%--%'));
    let deep = 0;
    const formatted = [];
    const shift = '   ';

    for (let x = 0, len = CSS.length; x < len; x++) {
        const line = CSS[x] + '\n';
        if (line.match(/\{/)) { // {
            formatted.push(shift.repeat(deep++) + line);
        } else if (line.match(/\}/)) {
            formatted.push(shift.repeat(--deep) + line);
        } else {
            formatted.push(shift.repeat(deep) + line);
        }
    }
    return formatted;
}

function getUniqueSelector(element: Node) {
    let currentElement = element;
    let path: string;
    while (!(currentElement.nodeName.toLowerCase() === 'html')) {
        let name = currentElement.nodeName;
        if (!name) {
            break;
        }
        name = name.toLowerCase();

        const parent = currentElement.parentElement;
        let index: number;
        const sameTagSiblings = [];
        for (let x = 0, len = parent.children.length; x < len; x++) {
            const node = parent.children[x];
            if (node.nodeName.toLowerCase() === name) {
                sameTagSiblings.push(node);
            }
            if (node === currentElement) {
                index = x;
            }
        }

        if (sameTagSiblings.length > 1) {
            name += `:nth-child(${index})`;
        }

        path = name + (path ? ' > ' + path : '');
        currentElement = parent;
    }

    return path;
}

export function exportCSSText() {
    const css = [];
    // Shameless plug to promote Dark Reader.
    css.push(
        '/*',
        '                                  Generated by                                  ',
        '                                                                                ',
        '  _____                   _        _____                       _                ',
        ' |  __ \\                 | |      |  __ \\                     | |               ',
        ' | |  | |   __ _   _ __  | | __   | |__) |   ___    __ _    __| |   ___   _ __  ',
        " | |  | |  / _` | | '__| | |/ /   |  _  /   / _ \\  / _` |  / _` |  / _ \\ | '__| ",
        ' | |__| | | (_| | | |    |   <    | | \\ \\  |  __/ | (_| | | (_| | |  __/ | |    ',
        ' |_____/   \\__,_| |_|    |_|\\_\\   |_|  \\_\\  \\___|  \\__,_|  \\__,_|  \\___| |_|    ',
        '                                                                                ',
        '                             https://darkreader.org                             ',
        '*/',
        '');

    const fallbackStyle = document.head.querySelector('.darkreader--fallback');
    const userAgentStyle = document.head.querySelector('.darkreader--user-agent');
    const textStyle = document.head.querySelector('.darkreader--text');
    const invertStyle = document.head.querySelector('.darkreader--invert');
    const overrideStyle = document.head.querySelector('.darkreader--override');
    const variableStyle = document.head.querySelector('.darkreader--variables');

    if (fallbackStyle && fallbackStyle.textContent) {
        css.push('/* Fallback Style */');
        css.push(fallbackStyle.textContent);
        css.push('');
    }

    if (userAgentStyle && userAgentStyle.textContent) {
        css.push('/* User-Agent Style */');
        css.push(userAgentStyle.textContent);
        css.push('');
    }

    if (textStyle && textStyle.textContent) {
        css.push('/* Text Style */');
        css.push(textStyle.textContent);
        css.push('');
    }

    if (invertStyle && invertStyle.textContent) {
        css.push('/* Invert Style */');
        css.push(invertStyle.textContent);
        css.push('');
    }

    if (overrideStyle && overrideStyle.textContent) {
        css.push('/* Override Style */');
        css.push(overrideStyle.textContent);
        css.push('');
    }

    if (variableStyle && variableStyle.textContent) {
        css.push('/* Variables Style */');
        css.push(variableStyle.textContent);
        css.push('');
    }

    const inlineCSS = [];
    overridesList.forEach((override) => {
        override.fullList.forEach((item) => {
            if (override.store.has(item)) {
                inlineCSS.push(`${getUniqueSelector(item)} { ${override.cssProp}: ${override.store.get(item)} }`);
            }
        });
    });
    if (inlineCSS.length != 0) {
        const beautifiedCSS = beautify(inlineCSS.join('\n'));
        css.push('/* Inline CSS */');
        css.push(beautifiedCSS.join(''));
        css.push('');
    }

    const modifiedCSS = [];
    styleManagers.forEach((manager) => {
        forEach(manager.modifiedRuleList().cssRules, (rule) => {
            modifiedCSS.push(`${rule.cssText}`);
        });

    });

    if (modifiedCSS.length != 0) {
        const beautifiedCSS = beautify(modifiedCSS.join('\n'));
        css.push('/* Modified CSS */');
        css.push(beautifiedCSS.join(''));
        css.push('');
    }

    chrome.runtime.sendMessage({type: 'export-css-response2', data: css.join('\n')});

}
